<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"index.js.html":{"id":"index.js.html","title":"Source: index.js","body":" Granax Modules granaxgranax/commandsgranax/replies Classes TorController Events TorController#event:closeTorController#event:errorTorController#event:ready Tutorials Running as Tor User Source: index.js /** * @module granax * @license AGPL-3.0 * @author Gordon Hall &lt;gordonh@member.fsf.org&gt; */ 'use strict'; /** * Returns a {@link TorController} with automatically constructed socket * @param {number} controlPort - Port to connect controller socket * @param {object} [controllerOptions] - @see {@link TorController} */ module.exports = function(controlPort, controllerOptions) { return new module.exports.TorController( require('net').connect(controlPort), controllerOptions ); }; /** * {@link TorController} */ module.exports.TorController = require('./lib/controller'); /** * {@link module:commands} */ module.exports.commands = require('./lib/commands'); /** * {@link module:replies} */ module.exports.replies = require('./lib/replies'); × Search results Close "},"lib_commands.js.html":{"id":"lib_commands.js.html","title":"Source: lib/commands.js","body":" Granax Modules granaxgranax/commandsgranax/replies Classes TorController Events TorController#event:closeTorController#event:errorTorController#event:ready Tutorials Running as Tor User Source: lib/commands.js /** * @module granax/commands */ 'use strict'; const merge = require('merge'); /** * @param {string} [token=&quot;&quot;] - The auth token * @returns {string} */ exports.AUTHENTICATE = function(token = '') { return `AUTHENTICATE ${token}`; }; /** * @param {string} [nonce=&quot;&quot;] - Client nonce for challenge * @param {string} [type=&quot;SAFECOOKIE&quot;] - The type of challenge * @returns {string} */ exports.AUTHCHALLENGE = function(nonce = '', type = 'SAFECOOKIE') { return `AUTHCHALLENGE ${type} ${nonce}`; }; /** * @returns {string} */ exports.PROTOCOLINFO = function() { return 'PROTOCOLINFO'; }; /** * @param {string} target - Address:Port string * @param {object} [options] * @param {string} [options.clientName] - Client auth identifier * @param {string} [options.clientBlob] - Arbitrary auth data * @param {number} [options.virtualPort=80] - Virtual port for the service * @param {string} [options.keyType=&quot;NEW&quot;] - Create a new key or use RSA1024 * @param {string} [options.keyBlob=&quot;BEST&quot;] - Key type to create or serialized * @param {boolean} [options.discardPrivateKey=false] - Do not return key * @param {boolean} [options.detach=false] - Keep service running after close * @param {boolean} [options.basicAuth=false] - Use client name and blob auth * @param {boolean} [options.nonAnonymous=false] - Non-anononymous mode */ exports.ADD_ONION = function(target, opts = {}) { let options = merge({ clientName: null, clientBlob: null, virtualPort: 80, keyType: 'NEW', keyBlob: 'BEST', discardPrivateKey: false, detach: false, basicAuth: false, nonAnonymous: false }, opts); let command = ['ADD_ONION', `${options.keyType}:${options.keyBlob}`]; let flags = [ ['discardPrivateKey', 'DiscardPK'], ['detach', 'Detach'], ['basicAuth', 'BasicAuth'], ['nonAnonymous', 'NonAnonymous'] ]; for (let flag in flags) { if (options[flag[0]]) { command.push(flag[1]); } } command.push(`Port=${options.virtualPort},${target}`); if (options.clientName &amp;&amp; options.clientBlob) { command.push(`ClientAuth=${options.clientName}:${options.clientBlob}`); } return command.join(' '); }; /** * @param {string} serviceId * @returns {string} */ exports.DEL_ONION = function(serviceId) { return `DEL_ONION ${serviceId}`; }; /** * @param {string} keyword * @param {string} value * @returns {string} */ exports.SETCONF = function(keyword, value) { return `SETCONF ${keyword}=&quot;${value}&quot;`; }; /** * @param {string} keyword * @returns {string} */ exports.RESETCONF = function(keyword) { return `RESETCONF ${keyword}`; }; /** * @param {string} keyword * @returns {string} */ exports.GETCONF = function(keyword) { return `GETCONF ${keyword}`; }; /** * @returns {string} */ exports.SAVECONF = function() { return 'SAVECONF'; }; /** * @returns {string} */ exports.SIGNAL = function(signal) { return `SIGNAL ${signal}`; }; /** * @param {string} targetAddr * @param {string} replaceAddr * @returns {string} */ exports.MAPADDRESS = function(targetAddr, replaceAddr) { return `MAPPADDRESS ${targetAddr}=${replaceAddr}`; }; /** * @param {string} circuitId * @returns {string} */ exports.EXTENDCIRCUIT = function(circuitId, purpose) { return `EXTENDCIRCUIT ${circuitId} ` + (purpose ? `purpose=&quot;${purpose}&quot;` : ''); }; /** * @param {string} circuitId * @param {string} purpose * */ exports.SETCIRCUITPURPOSE = function(circuitId, purpose) { return `SETCIRCUITPURPOSE ${circuitId} purpose=&quot;${purpose}&quot;`; }; /** * @param {string} streamId * @param {object} options * @param {string} options.circuitId * @param {string|null} options.hopNumber * @returns {string} */ exports.ATTACHSTREAM = function(streamId, options) { return `ATTACHSTREAM ${streamId} ${options.circuitId}` + (options.hopNumber ? `HOP=${options.hopNumber}` : ''); }; /** * @param {object} descriptor * @param {object} options * @param {string} [options.purpose=&quot;general&quot;] * @param {boolean} [options.cache=true] * @returns {string} */ exports.POSTDESCRIPTOR = function(descriptor, options) { options = merge({ purpose: 'general', cache: true }, options); let descStrings = []; for (let key in descriptor) { descStrings.push(`${key}=${descriptor[key]}`); } return [ `+POSTDESCRIPTOR purpose=${options.purpose} ` + `cache=${options.cache ? 'yes' : 'no'}`, descStrings.join('\\r\\n'), '.' ].join('\\r\\n'); }; /** * @param {string} streamId * @param {string} address * @param {number} [port] * @returns {string} */ exports.REDIRECTSTREAM = function(streamId, address, port = '') { return `REDIRECTSTREAM ${streamId} ${address} ${port}`; }; /** * @param {string} streamId * @param {number} [reason=1] * @returns {string} */ exports.CLOSESTREAM = function(streamId, reason = 1) { return `CLOSESTREAM ${streamId} ${reason}`; }; /** * @param {string} circuitId * @param {object} [options] * @param {boolean} [options.ifUnused=false] * @returns {string} */ exports.CLOSECIRCUIT = function(circuitId, options = { ifUnused: false }) { return `CLOSECIRCUIT ${circuitId}` + (options.ifUnused ? ' IfUnused' : ''); }; /** * @returns {string} */ exports.QUIT = function() { return 'QUIT'; }; /** * @param {string} address * @param {boolean} [reverse=false] * @returns {string} */ exports.RESOLVE = function(address, reverse) { return 'RESOLVE ' + (reverse ? 'mode=reverse ' : '') + address; }; /** * @param {string} configText * @returns {string} */ exports.LOADCONF = function(configText) { return `+LOADCONF\\r\\n${configText}\\r\\n.`; }; /** * @returns {string} */ exports.TAKEOWNERSHIP = function() { return 'TAKEOWNERSHIP'; }; /** * @returns {string} */ exports.DROPGUARDS = function() { return 'DROPGUARDS'; }; /** * @param {string} serviceId * @param {string} [serverLongName] * @returns {string} */ exports.HSFETCH = function(serviceId, serverLongName) { return 'HSFETCH ${serviceId}' + (serverLongName ? ` SERVER=${serverLongName}` : ''); }; /** * @param {string} descriptor * @param {string} [serverLongName] * @returns {string} */ exports.HSPOST = function(descriptor, serverLongName) { return '+HSPOST\\r\\n'+ (serverLongName ? `SERVER=${serverLongName}\\r\\n` : '') + `${descriptor}\\r\\n.`; }; /** * @param {string} keyword * @returns {string} */ exports.GETINFO = function(keyword) { return `GETINFO ${keyword}`; }; /** * @param {string[]} events * @returns {string} */ exports.SETEVENTS = function(events) { return `SETEVENTS ${events.join(' ')}`; }; × Search results Close "},"lib_replies.js.html":{"id":"lib_replies.js.html","title":"Source: lib/replies.js","body":" Granax Modules granaxgranax/commandsgranax/replies Classes TorController Events TorController#event:closeTorController#event:errorTorController#event:ready Tutorials Running as Tor User Source: lib/replies.js /** * @module granax/replies */ 'use strict'; /** * @param {string[]} output * @returns {AuthChallengeResult} */ exports.AUTHCHALLENGE = function(output) { let result = output[0].split(' '); let [, hash, nonce] = result; return { hash: hash.split('=').pop(), nonce: nonce ? nonce.split('=').pop() : null }; }; /** * @typedef {object} AuthChallengeResult * @property {string} hash - The server hash * @property {string} nonce - The server nonce */ /** * @param {string[]} output * @returns {ProtocolInfoResult} */ exports.PROTOCOLINFO = function(output) { let [proto, auth, version] = output; proto = proto.split(' '); auth = auth.split(' '); version = version.split(' '); return { protocol: proto[1], auth: { methods: auth[1].split('=')[1].split(','), cookieFile: auth[2] ? auth[2].split('=')[1].split('&quot;').join('') : null }, version: { tor: version[1].split('=')[1].split('&quot;').join('') } }; }; /** * @typedef {object} ProtocolInfoResult * @property {string} protocol * @property {object} auth * @property {string[]} auth.methods * @property {string} auth.cookieFile * @property {object} version * @property {string} version.tor */ /** * @param {string[]} output * @returns {AddOnionResult} */ exports.ADD_ONION = function(output) { return { serviceId: output[0].split('=')[1], privateKey: (output[1] &amp;&amp; output[1].includes('PrivateKey')) ? output[1].split('=')[1] : null }; }; /** * @typedef {object} AddOnionResult * @property {string} serviceId - The hidden service url without .onion * @property {string} [privateKey] - The generated private key */ /** * @param {string[]} output * @returns {GetConfigResult} */ exports.GETCONF = function(output) { return output.map((line) =&gt; line.split('=')[1]); }; /** * @typedef {string[]} GetConfigResult */ /** * @param {string[]} output * @returns {string} */ exports.GETINFO = function(output) { if (output.length &gt; 1) { return output.map((line) =&gt; line.split('=')[1]).join('\\n'); } return output.split('=')[1]; }; × Search results Close "},"lib_controller.js.html":{"id":"lib_controller.js.html","title":"Source: lib/controller.js","body":" Granax Modules granaxgranax/commandsgranax/replies Classes TorController Events TorController#event:closeTorController#event:errorTorController#event:ready Tutorials Running as Tor User Source: lib/controller.js 'use strict'; const crypto = require('crypto'); const async = require('async'); const { Transform: TransformStream } = require('stream'); const merge = require('merge'); const { readFileSync } = require('fs'); const { EventEmitter } = require('events'); const commands = require('./commands'); const replies = require('./replies'); /** * Represents a Tor controller for issuing commands */ class TorController extends EventEmitter { static get CLIENT_HASH() { return 'Tor safe cookie authentication controller-to-server hash'; } static get SERVER_HASH() { return 'Tor safe cookie authentication server-to-controller hash'; } /** * Creates the challenge response from a SAFECOOKIE challenge * @param {string} cookie - The secret cookie string * @param {string} clientNonce - Client nonce sent with auth challenge * @param {string} serverNonce - Server nonce reply from auth challenge * @returns {string} */ static createChallengeResponse(cookie, clientNonce, serverNonce) { return crypto.createHmac('sha256', TorController.CLIENT_HASH) .update(Buffer.concat([ Buffer.from(cookie, 'hex'), Buffer.from(clientNonce, 'hex'), Buffer.from(serverNonce, 'hex') ])) .digest('hex'); } /** * Fired when the underlying socket encounters an error * @event TorController#error * @type {error} */ /** * Fires when the controller is authenticated and ready to send commands * @event TorController#ready */ /** * Fires when the underlying socket closes * @event TorController#close */ static get DEFAULTS() { return { authOnConnect: true }; } /** * @constructor * @param {Socket} socket - net.Socket connected to Tor's control port * @param {object} [options] * @param {boolean} [options.authOnConnect=true] - Automatically authenticate */ constructor(socket, options) { super(); this._opts = merge(TorController.DEFAULTS, options); this._stack = []; this.socket = socket .on('connect', () =&gt; this._handleConnect()) .on('error', (err) =&gt; this._handleError(err)) .on('close', () =&gt; this._handleClose()); this.socket.pipe(this._createReplySplitter()) .on('data', (data) =&gt; this._handleReply(data)); } /** * Handles authentication routine on socket connect * @private * @param {function} callback */ _authOnConnect(callback) { const self = this; const clientNonce = crypto.randomBytes(32).toString('hex'); function maybeGetChallenge(cookie, authTypes, next) { if (authTypes.includes('SAFECOOKIE')) { self.getAuthChallenge(clientNonce, (err, result) =&gt; { next(err, result, cookie) }); } else { next(null, {}, cookie); } } function sendAuthCommand({ hash, nonce }, cookie, next) { if (!(hash &amp;&amp; nonce)) { return self.authenticate(cookie, next); } self.authenticate(TorController.createChallengeResponse( cookie, clientNonce, nonce, hash ), next); } async.waterfall([ (next) =&gt; this._getAuthCookie(next), (cookie, authTypes, next) =&gt; maybeGetChallenge(cookie, authTypes, next), (challenge, cookie, next) =&gt; sendAuthCommand(challenge, cookie, next) ], callback); } /** * Handles authentication upon socket connection * @private */ _handleConnect() { if (this._opts.authOnConnect) { this._authOnConnect((err) =&gt; this.emit(err ? 'error': 'ready', err)); } else { this.emit('ready'); } } /** * Handles errors on the underlying socket and bubbles them * @private * @param {object} error */ _handleError(err) { this.emit('error', err); } /** * Creates a message splitter from incoming socket data * @private */ _createReplySplitter() { return new TransformStream({ objectMode: true, transform: function(data, enc, next) { let reply = []; let lines = data.toString().split('\\r\\n'); for (let line of lines) { reply.push(line); if (line[3] === ' ') { this.push(reply); reply = []; } } next(null); } }); } /** * Handles message processing and parsing from the socket * @private * @param {buffer} data */ _handleReply(data) { let code = parseInt(data[0].substr(0, 3)); let lines = data .filter((line) =&gt; !!line) .map((line) =&gt; line.substr(4).trim()); switch (code.toString()[0]) { case '2': let { method, callback } = this._stack.pop(); let parsed = replies[method] ? replies[method](lines) : lines; callback(null, parsed); break; case '4': case '5': this._stack.pop().callback(new Error(lines[0])); break; case '6': default: let event = lines[0].split(' ')[0]; lines[0] = lines[0].replace(`${event} `, ''); this.emit(event, lines); } } /** * Handles socket close event and bubbles it * @private */ _handleClose() { this.emit('close'); } /** * Send an arbitrary command and pass response to callback * @private * @param {string} command * @param {function} callback */ _send(command, callback) { const self = this; callback = callback || function(err) { if (err) { self.emit('error', err); } }; this._stack.unshift({ method: command.split(' ')[0], callback }); this.socket.write(`${command}\\r\\n`); } /** * Load the authentication cookie * @private * @param {TorController~_getAuthCookieCallback} callback */ _getAuthCookie(callback) { this.getProtocolInfo((err, info) =&gt; { if (err) { return callback(err); } try { callback( null, info.auth.cookieFile ? readFileSync(info.auth.cookieFile).toString('hex') : '', info.auth.methods ); } catch (err) { callback(err); } }); } /** * @private * @callback TorController~_getAuthCookieCallback * @param {object|null} error * @param {string} cookie * @param {string[]} authTypes */ /** * Authenticates with the control port given the supplied param * @param {string} token * @param {TorController~authenticateCallback} callback */ authenticate(token, callback) { this._send(commands.AUTHENTICATE(token), callback); } /** * Requests an authentication challenge from tor * @param {string} nonce - Client nonce for authenticating * @param {TorController~getAuthChallengeCallback} callback */ getAuthChallenge(nonce, callback) { this._send(commands.AUTHCHALLENGE(nonce), callback); } /** * @callback TorController~getAuthChallengeCallback * @param {object|null} error * @param {AuthChallengeResult} result */ /** * Ask tor for general information * @param {TorController~getProtocolInfoCallback} callback */ getProtocolInfo(callback) { this._send(commands.PROTOCOLINFO(), callback); } /** * @callback TorController~getProtocolInfoCallback * @param {object|null} error * @param {ProtocolInfoResult} result */ /** * Establishes a hidden service on the given target * @param {string} target - The target ip:port string * @param {object} [options] - {@link module:commands#ADD_ONION} * @param {TorController~createHiddenServiceCallback} callback */ createHiddenService(target, options, callback) { if (typeof options === 'function') { callback = options; options = {}; } this._send(commands.ADD_ONION(target, options), callback); } /** * @callback TorController~createHiddenServiceCallback * @param {object|null} error * @param {AddOnionResult} result */ /** * Takes down a running hidden service owned by this controller * @param {string} serviceId - Tor hidden service ID * @param {TorController~destroyHiddenServiceCallback} callback */ destroyHiddenService(serviceId, callback) { this._send(commands.DEL_ONION(serviceId), callback); } /** * @callback TorController~destroyHiddenServiceCallback * @param {object|null} error */ /** * Change the value for a configuration variable * @param {string} keyword - Configuration key * @param {string} value - New value to set * @param {TorController~setConfigCallback} callback */ setConfig(keyword, value, callback) { this._send(commands.SETCONF(keyword, value), callback); } /** * @callback TorController~setConfigCallback * @param {object|null} error */ /** * Change the value for a configuration variable to it's default * @param {string} keyword - Configuration key * @param {TorController~resetConfigCallback} callback */ resetConfig(keyword, callback) { this._send(commands.RESETCONF(keyword), callback); } /** * @callback TorController~resetConfigCallback * @param {object|null} error */ /** * Return the values for the given configuration key * @param {string} keyword - Configuration key * @param {TorController~getConfigCallback} callback */ getConfig(keyword, callback) { this._send(commands.GETCONF(keyword), callback); } /** * @callback TorController~getConfigCallback * @param {object|null} error * @param {GetConfigResult} result */ /** * Tell Tor to write out it's config value to it's torrc * @param {TorController~saveConfigCallback} callback */ saveConfig(callback) { this._send(commands.SAVECONF(), callback); } /** * @callback TorController~saveConfigCallback * @param {object|null} error */ /** * Reloads the config values set * @param {TorController~reloadConfigCallback} callback */ reloadConfig(callback) { this.signal('RELOAD', callback); } /** * @callback TorController~reloadConfigCallback * @param {object|null} error */ /** * Controlled shutdown signal * @param {TorController~shutdownCallback} callback */ shutdown(callback) { this.signal('SHUTDOWN', callback); } /** * @callback TorController~shutdownCallback * @param {object|null} error */ /** * Dump stats to tor log file * @param {TorController~dumpStatsCallback} callback */ dumpStats(callback) { this.signal('DUMP', callback); } /** * @callback TorController~dumpStatsCallback * @param {object|null} error */ /** * Set open logs to debug level * @param {TorController~enableDebugCallback} callback */ enableDebug(callback) { this.signal('DEBUG', callback); } /** * @callback TorController~enableDebugCallback * @param {object|null} error */ /** * Shutdown tor immediately * @param {TorController~haltCallback} callback */ halt(callback) { this.signal('HALT', callback); } /** * @callback TorController~haltCallback * @param {object|null} error */ /** * Forget client side hostname-&gt;ip cache * @param {TorController~clearDnsCacheCallback} callback */ clearDnsCache(callback) { this.signal('CLEARDNSCACHE', callback); } /** * @callback TorController~clearDnsCacheCallback * @param {object|null} error */ /** * Clears DNS cache and establishes new clean circuits * @param {TorController~cleanCircuitsCallback} callback */ cleanCircuits(callback) { this.signal('NEWNYM', callback); } /** * @callback TorController~cleanCircuitsCallback * @param {object|null} error */ /** * Dumps a heartbeat message to the logs * @param {TorController~dumpHeartbeatCallback} callback */ dumpHeartbeat(callback) { this.signal('HEARTBEAT', callback); } /** * @callback TorController~dumpHeartbeatCallback * @param {object|null} error */ /** * Sends a signal to the control port * @param {string} signal * @param {TorController~signalCallback} callback */ signal(sig, callback) { this._send(commands.SIGNAL(sig), callback); } /** * @callback TorController~signalCallback * @param {object|null} error */ /** * Instruct Tor to route requests to the target to the replacement * @param {string} target - Original address to map * @param {string} replacement - New address to route request to target * @param {TorController~createAddressMappingCallback} callback */ createAddressMapping(target, replacement, callback) { this._send(commands.MAPADDRESS(target, replacement), callback); } /** * @callback TorController~createAddressMappingCallback * @param {object|null} error */ /** * Creates a new circuit, returning the newly created circuit ID * @param {string} [purpose=&quot;general&quot;] - The circuit purpose, either general|controller * @param {TorController~createCircuitCallback} */ createCircuit(purpose, callback) { if (typeof purpose === 'function') { callback = purpose; purpose = null; } this._send(commands.EXTENDCIRCUIT('0', purpose), callback); } /** * @callback TorController~createCircuitCallback * @param {object|null} error * @param {string[]} result */ /** * Extends the existing circuit * @param {string} circuitId - The circuit ID to extend * @param {TorController~extendCircuitCallback} */ extendCircuit(id, callback) { this._send(commands.EXTENDCIRCUIT(id), callback); } /** * @callback TorController~extendCircuitCallback * @param {object|null} error * @param {string[]} result */ /** * Sets the purpose of the given circuit * @param {string} circuitId - The identifier for the circuit * @param {string} purpose - One of general|controller * @param {TorController~setCircuitPurposeCallback} callback */ setCircuitPurpose(circuitId, purpose, callback) { this._send(commands.SETCIRCUITPURPOSE(circuitId, purpose), callback); } /** * @callback TorController~setCircuitPurposeCallback * @param {object|null} error */ /** * Attaches the specified stream to the given circuit * @param {string} streamId - ID for the stream to attach * @param {string} [circuitId=0] - Circuit to attach stream * @param {number} [hopNumber] - Which hop to exit circuit * @param {TorController~attachStreamCallback} callback */ attachStream(streamId, options, callback) { if (typeof options === 'function') { callback = options; options = { circuitId: '0', hopNumber: null }; } this._send(commands.ATTACHSTREAM(streamId, options), callback); } /** * @callback TorController~attachStreamCallback * @param {object|null} error */ /** * Inform the server about a new descriptor * @param {object} descriptor - Key-value pairs for server descriptor * @param {object} [options] * @param {string} [options.purpose=&quot;general&quot;] - general|controller|bridge * @param {boolean} [options.cache=true] - Flag for caching descriptor * @param {TorController~postDescriptorCallback} callback */ postDescriptor(descriptor, options, callback) { if (typeof options === 'function') { callback = options; options = {}; } this._send(commands.POSTDESCRIPTOR(descriptor, options), callback); } /** * @callback TorController~postDescriptorCallback * @param {object|null} error */ /** * Change the exit address on a given stream * @param {string} streamId - ID for stream to redirect * @param {string} address - Exit address for the given stream * @param {number} [port] - Exit port for the given stream * @param {TorController~redirectStreamCallback} callback */ redirectStream(streamId, address, port, callback) { if (typeof port === 'function') { callback = port; port = null; } this._send(commands.REDIRECTSTREAM(streamId, address, port), callback); } /** * @callback TorController~redirectStreamCallback * @param {object|null} error */ /** * Closes the exit for the given stream * @param {string} streamId - ID for the stream to close * @param {number} [reason=1] - Reason code for closing stream * @param {TorController~closeStreamCallback} callback * @see https://gitweb.torproject.org/torspec.git/tree/tor-spec.txt#n1404 */ closeStream(streamId, reason, callback) { if (typeof reason === 'function') { callback = reason; reason = 1; } this._send(commands.CLOSESTREAM(streamId, reason), callback); } /** * @callback TorController~closeStreamCallback * @param {object|null} error */ /** * Closes the given circuit * @param {string} circuitId - ID for the circuit to close * @param {object} [options] * @param {boolean} [options.ifUnused=false] - Only close if not in use * @param {TorController~closeCircuitCallback} callback */ closeCicuit(circuitId, options, callback) { if (typeof options === 'function') { callback = options; options = { ifUnused: false }; } this._send(commands.CLOSECIRCUIT(circuitId, options), callback); } /** * @callback TorController~closeCircuitCallback * @param {object|null} error */ /** * Tells Tor to hang up on the controller * @param {TorController~quitCallback} callback */ quit(callback) { this._send(commands.QUIT(), callback); } /** * @callback TorController~quitCallback * @param {object|null} error */ /** * Launch remote hostname lookup - answer returnd as async ADDRMAP event * @param {string} address - Address to lookup * @param {object} [options] * @param {boolean} [options.reverse=false] - Perform reverse lookup * @param {TorController~resolveCallback} callback */ resolve(address, options, callback) { if (typeof options === 'function') { callback = options; options = {}; } this._send(commands.RESOLVE(address, options.reverse), callback); } /** * @callback TorController~resolveCallback * @param {object|null} error */ /** * Instruct Tor to load the configuration file from the given path * @param {string} configFilePath - Path to the config to read and send * @param {TorController~loadConfigCallback} callback */ loadConfig(configFilePath, callback) { let configText = null; try { configText = readFileSync(configFilePath).toString(); } catch (err) { return callback(err); } this._send(commands.LOADCONF(configText), callback); } /** * @callback TorController~loadConfigCallback * @param {object|null} error */ /** * Take ownership of the tor process - will close tor when the connection * closes * @param {TorController~takeOwnershipCallback} callback */ takeOwnership(callback) { this._send(commands.TAKEOWNERSHIP(), (err) =&gt; { if (err) { return callback(err); } this.resetConfig('__OwningControllerProcess', callback); }); } /** * @callback TorController~takeOwnershipCallback * @param {object|null} error */ /** * Tells the server to drop all guard nodes. Do not invoke this command * lightly; it can increase vulnerability to tracking attacks over time. * @param {TorController~dropGuardsCallback} callback */ dropGuards(callback) { this._send(commands.DROPGUARDS(), callback); } /** * @callback TorController~dropGuardsCallback * @param {object|null} error */ /** * Fetches descriptors for the given hidden service * @param {string} serviceId - ID for the hidden service * @param {string} [serverLongName] - Long name for specific server to use * @param {TorController~fetchHiddenServiceDescriptorCallback} callback */ fetchHiddenServiceDescriptor(serviceId, serverLongName, callback) { if (typeof serverLongName === 'function') { callback = serverLongName; serverLongName = ''; } this._send(commands.HSFETCH(serviceId, serverLongName), callback); } /** * @callback TorController~fetchHiddenServiceDescriptorCallback * @param {object|null} error */ /** * Launch a hidden service descriptor upload * @param {string} descriptor * @param {string} [serverLongName] - Long name for specific server to use * @param {TorController~postHiddenServiceDescriptorCallback} callback * @see https://gitweb.torproject.org/torspec.git/tree/rend-spec.txt#n193 */ postHiddenServiceDescriptor(descriptor, serverLongName, callback) { if (typeof serverLongName === 'function') { callback = serverLongName; serverLongName = ''; } this._send(commands.HSPOST(descriptor, serverLongName), callback); } /** * @callback TorController~postHiddenServiceDescriptorCallback * @param {object|null} error */ /** * Get information from Tor not stored in configuration * @param {string} keyword - Keyword for info to fetch * @param {TorController~getInfoCallback} callback * @see https://gitweb.torproject.org/torspec.git/tree/control-spec.txt#n500 */ getInfo(keyword, callback) { this._send(commands.GETINFO(keyword), callback); } /** * @callback TorController~getInfoCallback * @param {object|null} error * @param {string} result */ /** * Instructs Tor to send asynchronous events for the given types - these * events will be emitted from the controller. Calling this method resets * previously set event listeners * @param {string[]} events - List of event types to listen for * @param {TorController~addEventListenersCallback} callback * @see https://gitweb.torproject.org/torspec.git/tree/control-spec.txt#n1708 */ addEventListeners(events, callback) { this._send(commands.SETEVENTS(events), callback); } /** * @callback TorController~addEventListenersCallback * @param {object|null} error */ /** * Instructs Tor to stop listening for events * @param {TorController~removeEventListenersCallback} callback */ removeEventListeners(callback) { this._send(commands.SETEVENTS([]), callback); } /** * @callback TorController~removeEventListenersCallback * @param {object|null} error */ } module.exports = TorController; × Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" Granax Modules granaxgranax/commandsgranax/replies Classes TorController Events TorController#event:closeTorController#event:errorTorController#event:ready Tutorials Running as Tor User Modules Classes TorController Events close Fires when the underlying socket closes Source: lib/controller.js error Fired when the underlying socket encounters an error Type: error Source: lib/controller.js ready Fires when the controller is authenticated and ready to send commands Source: lib/controller.js × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Granax Modules granaxgranax/commandsgranax/replies Classes TorController Events TorController#event:closeTorController#event:errorTorController#event:ready Tutorials Running as Tor User Classes Classes TorController Events close Fires when the underlying socket closes Source: lib/controller.js error Fired when the underlying socket encounters an error Type: error Source: lib/controller.js ready Fires when the controller is authenticated and ready to send commands Source: lib/controller.js × Search results Close "},"tutorials.list.html":{"id":"tutorials.list.html","title":"Tutorials","body":" Granax Modules granaxgranax/commandsgranax/replies Classes TorController Events TorController#event:closeTorController#event:errorTorController#event:ready Tutorials Running as Tor User Tutorials Classes TorController Events close Fires when the underlying socket closes Source: lib/controller.js error Fired when the underlying socket encounters an error Type: error Source: lib/controller.js ready Fires when the controller is authenticated and ready to send commands Source: lib/controller.js × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" Granax Modules granaxgranax/commandsgranax/replies Classes TorController Events TorController#event:closeTorController#event:errorTorController#event:ready Tutorials Running as Tor User Complete client implementation of the Tor Control Protocol. Control a running Tor instance from Node.js! UsageInstall via NPM: npm install granax --saveMake sure that ControlPort=9051 (or your preferred port) is set in your torrc, then you may open the control socket and issue commands: const tor = require('granax')(9051, options); tor.on('ready', function() { tor.createHiddenService('127.0.0.1:8080', (err, result) =&gt; { console.info(`Service URL: ${result.serviceId}.onion`); console.info(`Private Key: ${result.privateKey}`); }); }); tor.on('error', function(err) { console.error(err); }); Note that if using cookie authentication, the Node.js process must have the appropriate privileges to read the cookie file. Usually, this means running as the same user that is running Tor. Resources Granax Examples Granax Documentation Tor Control Specification Tor Documentation LicenseGranax - Complete client implementation of the Tor Control ProtocolCopyright (C) 2017 Gordon Hall This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details. You should have received a copy of the GNU Affero General Public License along with this program. If not, see . × Search results Close "},"module-granax.html":{"id":"module-granax.html","title":"Module: granax","body":" Granax Modules granaxgranax/commandsgranax/replies Classes TorController Events TorController#event:closeTorController#event:errorTorController#event:ready Tutorials Running as Tor User Module: granax (require(&quot;granax&quot;))(controlPort [, controllerOptions]) Returns a TorController with automatically constructed socket Parameters: Name Type Argument Description controlPort number Port to connect controller socket controllerOptions object &lt;optional&gt; @see TorController Source: index.js Members &lt;static&gt; commands module:commands Source: index.js &lt;static&gt; replies module:replies Source: index.js &lt;static&gt; TorController TorController Source: index.js × Search results Close "},"module-granax_commands.html":{"id":"module-granax_commands.html","title":"Module: granax/commands","body":" Granax Modules granaxgranax/commandsgranax/replies Classes TorController Events TorController#event:closeTorController#event:errorTorController#event:ready Tutorials Running as Tor User Module: granax/commands Source: lib/commands.js Methods &lt;static&gt; ADD_ONION(target [, options]) Parameters: Name Type Argument Description target string Address:Port string options object &lt;optional&gt; Properties Name Type Argument Default Description clientName string &lt;optional&gt; Client auth identifier clientBlob string &lt;optional&gt; Arbitrary auth data virtualPort number &lt;optional&gt; 80 Virtual port for the service keyType string &lt;optional&gt; &quot;NEW&quot; Create a new key or use RSA1024 keyBlob string &lt;optional&gt; &quot;BEST&quot; Key type to create or serialized discardPrivateKey boolean &lt;optional&gt; false Do not return key detach boolean &lt;optional&gt; false Keep service running after close basicAuth boolean &lt;optional&gt; false Use client name and blob auth nonAnonymous boolean &lt;optional&gt; false Non-anononymous mode Source: lib/commands.js &lt;static&gt; ATTACHSTREAM(streamId, options) Parameters: Name Type Description streamId string options object Properties Name Type Description circuitId string hopNumber string | null Source: lib/commands.js Returns: Type string &lt;static&gt; AUTHCHALLENGE( [nonce] [, type]) Parameters: Name Type Argument Default Description nonce string &lt;optional&gt; &quot;&quot; Client nonce for challenge type string &lt;optional&gt; &quot;SAFECOOKIE&quot; The type of challenge Source: lib/commands.js Returns: Type string &lt;static&gt; AUTHENTICATE( [token]) Parameters: Name Type Argument Default Description token string &lt;optional&gt; &quot;&quot; The auth token Source: lib/commands.js Returns: Type string &lt;static&gt; CLOSECIRCUIT(circuitId [, options]) Parameters: Name Type Argument Description circuitId string options object &lt;optional&gt; Properties Name Type Argument Default Description ifUnused boolean &lt;optional&gt; false Source: lib/commands.js Returns: Type string &lt;static&gt; CLOSESTREAM(streamId [, reason]) Parameters: Name Type Argument Default Description streamId string reason number &lt;optional&gt; 1 Source: lib/commands.js Returns: Type string &lt;static&gt; DEL_ONION(serviceId) Parameters: Name Type Description serviceId string Source: lib/commands.js Returns: Type string &lt;static&gt; DROPGUARDS() Source: lib/commands.js Returns: Type string &lt;static&gt; EXTENDCIRCUIT(circuitId) Parameters: Name Type Description circuitId string Source: lib/commands.js Returns: Type string &lt;static&gt; GETCONF(keyword) Parameters: Name Type Description keyword string Source: lib/commands.js Returns: Type string &lt;static&gt; GETINFO(keyword) Parameters: Name Type Description keyword string Source: lib/commands.js Returns: Type string &lt;static&gt; HSFETCH(serviceId [, serverLongName]) Parameters: Name Type Argument Description serviceId string serverLongName string &lt;optional&gt; Source: lib/commands.js Returns: Type string &lt;static&gt; HSPOST(descriptor [, serverLongName]) Parameters: Name Type Argument Description descriptor string serverLongName string &lt;optional&gt; Source: lib/commands.js Returns: Type string &lt;static&gt; LOADCONF(configText) Parameters: Name Type Description configText string Source: lib/commands.js Returns: Type string &lt;static&gt; MAPADDRESS(targetAddr, replaceAddr) Parameters: Name Type Description targetAddr string replaceAddr string Source: lib/commands.js Returns: Type string &lt;static&gt; POSTDESCRIPTOR(descriptor, options) Parameters: Name Type Description descriptor object options object Properties Name Type Argument Default Description purpose string &lt;optional&gt; &quot;general&quot; cache boolean &lt;optional&gt; true Source: lib/commands.js Returns: Type string &lt;static&gt; PROTOCOLINFO() Source: lib/commands.js Returns: Type string &lt;static&gt; QUIT() Source: lib/commands.js Returns: Type string &lt;static&gt; REDIRECTSTREAM(streamId, address [, port]) Parameters: Name Type Argument Description streamId string address string port number &lt;optional&gt; Source: lib/commands.js Returns: Type string &lt;static&gt; RESETCONF(keyword) Parameters: Name Type Description keyword string Source: lib/commands.js Returns: Type string &lt;static&gt; RESOLVE(address [, reverse]) Parameters: Name Type Argument Default Description address string reverse boolean &lt;optional&gt; false Source: lib/commands.js Returns: Type string &lt;static&gt; SAVECONF() Source: lib/commands.js Returns: Type string &lt;static&gt; SETCIRCUITPURPOSE(circuitId, purpose) Parameters: Name Type Description circuitId string purpose string Source: lib/commands.js &lt;static&gt; SETCONF(keyword, value) Parameters: Name Type Description keyword string value string Source: lib/commands.js Returns: Type string &lt;static&gt; SETEVENTS(events) Parameters: Name Type Description events Array.&lt;string&gt; Source: lib/commands.js Returns: Type string &lt;static&gt; SIGNAL() Source: lib/commands.js Returns: Type string &lt;static&gt; TAKEOWNERSHIP() Source: lib/commands.js Returns: Type string × Search results Close "},"module-granax_replies.html":{"id":"module-granax_replies.html","title":"Module: granax/replies","body":" Granax Modules granaxgranax/commandsgranax/replies Classes TorController Events TorController#event:closeTorController#event:errorTorController#event:ready Tutorials Running as Tor User Module: granax/replies Source: lib/replies.js Methods &lt;static&gt; ADD_ONION(output) Parameters: Name Type Description output Array.&lt;string&gt; Source: lib/replies.js Returns: Type AddOnionResult &lt;static&gt; AUTHCHALLENGE(output) Parameters: Name Type Description output Array.&lt;string&gt; Source: lib/replies.js Returns: Type AuthChallengeResult &lt;static&gt; GETCONF(output) Parameters: Name Type Description output Array.&lt;string&gt; Source: lib/replies.js Returns: Type GetConfigResult &lt;static&gt; GETINFO(output) Parameters: Name Type Description output Array.&lt;string&gt; Source: lib/replies.js Returns: Type string &lt;static&gt; PROTOCOLINFO(output) Parameters: Name Type Description output Array.&lt;string&gt; Source: lib/replies.js Returns: Type ProtocolInfoResult Type Definitions AddOnionResult Type: object Properties: Name Type Argument Description serviceId string The hidden service url without .onion privateKey string &lt;optional&gt; The generated private key Source: lib/replies.js AuthChallengeResult Type: object Properties: Name Type Description hash string The server hash nonce string The server nonce Source: lib/replies.js GetConfigResult Type: Array.&lt;string&gt; Source: lib/replies.js ProtocolInfoResult Type: object Properties: Name Type Description protocol string auth object Properties Name Type Description methods Array.&lt;string&gt; cookieFile string version object Properties Name Type Description tor string Source: lib/replies.js × Search results Close "},"TorController.html":{"id":"TorController.html","title":"Class: TorController","body":" Granax Modules granaxgranax/commandsgranax/replies Classes TorController Events TorController#event:closeTorController#event:errorTorController#event:ready Tutorials Running as Tor User Class: TorController TorController Represents a Tor controller for issuing commands new TorController(socket [, options]) Parameters: Name Type Argument Description socket Socket net.Socket connected to Tor's control port options object &lt;optional&gt; Properties Name Type Argument Default Description authOnConnect boolean &lt;optional&gt; true Automatically authenticate Source: lib/controller.js Methods &lt;static&gt; createChallengeResponse(cookie, clientNonce, serverNonce) Creates the challenge response from a SAFECOOKIE challenge Parameters: Name Type Description cookie string The secret cookie string clientNonce string Client nonce sent with auth challenge serverNonce string Server nonce reply from auth challenge Source: lib/controller.js Returns: Type string addEventListeners(events, callback) Instructs Tor to send asynchronous events for the given types - these events will be emitted from the controller. Calling this method resets previously set event listeners Parameters: Name Type Description events Array.&lt;string&gt; List of event types to listen for callback TorController~addEventListenersCallback Source: lib/controller.js See: https://gitweb.torproject.org/torspec.git/tree/control-spec.txt#n1708 attachStream(streamId [, circuitId] [, hopNumber], callback) Attaches the specified stream to the given circuit Parameters: Name Type Argument Default Description streamId string ID for the stream to attach circuitId string &lt;optional&gt; 0 Circuit to attach stream hopNumber number &lt;optional&gt; Which hop to exit circuit callback TorController~attachStreamCallback Source: lib/controller.js authenticate(token, callback) Authenticates with the control port given the supplied param Parameters: Name Type Description token string callback TorController~authenticateCallback Source: lib/controller.js cleanCircuits(callback) Clears DNS cache and establishes new clean circuits Parameters: Name Type Description callback TorController~cleanCircuitsCallback Source: lib/controller.js clearDnsCache(callback) Forget client side hostname-&gt;ip cache Parameters: Name Type Description callback TorController~clearDnsCacheCallback Source: lib/controller.js closeCicuit(circuitId [, options], callback) Closes the given circuit Parameters: Name Type Argument Description circuitId string ID for the circuit to close options object &lt;optional&gt; Properties Name Type Argument Default Description ifUnused boolean &lt;optional&gt; false Only close if not in use callback TorController~closeCircuitCallback Source: lib/controller.js closeStream(streamId [, reason], callback) Closes the exit for the given stream Parameters: Name Type Argument Default Description streamId string ID for the stream to close reason number &lt;optional&gt; 1 Reason code for closing stream callback TorController~closeStreamCallback Source: lib/controller.js See: https://gitweb.torproject.org/torspec.git/tree/tor-spec.txt#n1404 createAddressMapping(target, replacement, callback) Instruct Tor to route requests to the target to the replacement Parameters: Name Type Description target string Original address to map replacement string New address to route request to target callback TorController~createAddressMappingCallback Source: lib/controller.js createCircuit( [purpose], callback) Creates a new circuit, returning the newly created circuit ID Parameters: Name Type Argument Default Description purpose string &lt;optional&gt; &quot;general&quot; The circuit purpose, either general|controller callback TorController~createCircuitCallback Source: lib/controller.js createHiddenService(target [, options], callback) Establishes a hidden service on the given target Parameters: Name Type Argument Description target string The target ip:port string options object &lt;optional&gt; module:commands#ADD_ONION callback TorController~createHiddenServiceCallback Source: lib/controller.js destroyHiddenService(serviceId, callback) Takes down a running hidden service owned by this controller Parameters: Name Type Description serviceId string Tor hidden service ID callback TorController~destroyHiddenServiceCallback Source: lib/controller.js dropGuards(callback) Tells the server to drop all guard nodes. Do not invoke this command lightly; it can increase vulnerability to tracking attacks over time. Parameters: Name Type Description callback TorController~dropGuardsCallback Source: lib/controller.js dumpHeartbeat(callback) Dumps a heartbeat message to the logs Parameters: Name Type Description callback TorController~dumpHeartbeatCallback Source: lib/controller.js dumpStats(callback) Dump stats to tor log file Parameters: Name Type Description callback TorController~dumpStatsCallback Source: lib/controller.js enableDebug(callback) Set open logs to debug level Parameters: Name Type Description callback TorController~enableDebugCallback Source: lib/controller.js extendCircuit(circuitId, callback) Extends the existing circuit Parameters: Name Type Description circuitId string The circuit ID to extend callback TorController~extendCircuitCallback Source: lib/controller.js fetchHiddenServiceDescriptor(serviceId [, serverLongName], callback) Fetches descriptors for the given hidden service Parameters: Name Type Argument Description serviceId string ID for the hidden service serverLongName string &lt;optional&gt; Long name for specific server to use callback TorController~fetchHiddenServiceDescriptorCallback Source: lib/controller.js getAuthChallenge(nonce, callback) Requests an authentication challenge from tor Parameters: Name Type Description nonce string Client nonce for authenticating callback TorController~getAuthChallengeCallback Source: lib/controller.js getConfig(keyword, callback) Return the values for the given configuration key Parameters: Name Type Description keyword string Configuration key callback TorController~getConfigCallback Source: lib/controller.js getInfo(keyword, callback) Get information from Tor not stored in configuration Parameters: Name Type Description keyword string Keyword for info to fetch callback TorController~getInfoCallback Source: lib/controller.js See: https://gitweb.torproject.org/torspec.git/tree/control-spec.txt#n500 getProtocolInfo(callback) Ask tor for general information Parameters: Name Type Description callback TorController~getProtocolInfoCallback Source: lib/controller.js halt(callback) Shutdown tor immediately Parameters: Name Type Description callback TorController~haltCallback Source: lib/controller.js loadConfig(configFilePath, callback) Instruct Tor to load the configuration file from the given path Parameters: Name Type Description configFilePath string Path to the config to read and send callback TorController~loadConfigCallback Source: lib/controller.js postDescriptor(descriptor [, options], callback) Inform the server about a new descriptor Parameters: Name Type Argument Description descriptor object Key-value pairs for server descriptor options object &lt;optional&gt; Properties Name Type Argument Default Description purpose string &lt;optional&gt; &quot;general&quot; general|controller|bridge cache boolean &lt;optional&gt; true Flag for caching descriptor callback TorController~postDescriptorCallback Source: lib/controller.js postHiddenServiceDescriptor(descriptor [, serverLongName], callback) Launch a hidden service descriptor upload Parameters: Name Type Argument Description descriptor string serverLongName string &lt;optional&gt; Long name for specific server to use callback TorController~postHiddenServiceDescriptorCallback Source: lib/controller.js See: https://gitweb.torproject.org/torspec.git/tree/rend-spec.txt#n193 quit(callback) Tells Tor to hang up on the controller Parameters: Name Type Description callback TorController~quitCallback Source: lib/controller.js redirectStream(streamId, address [, port], callback) Change the exit address on a given stream Parameters: Name Type Argument Description streamId string ID for stream to redirect address string Exit address for the given stream port number &lt;optional&gt; Exit port for the given stream callback TorController~redirectStreamCallback Source: lib/controller.js reloadConfig(callback) Reloads the config values set Parameters: Name Type Description callback TorController~reloadConfigCallback Source: lib/controller.js removeEventListeners(callback) Instructs Tor to stop listening for events Parameters: Name Type Description callback TorController~removeEventListenersCallback Source: lib/controller.js resetConfig(keyword, callback) Change the value for a configuration variable to it's default Parameters: Name Type Description keyword string Configuration key callback TorController~resetConfigCallback Source: lib/controller.js resolve(address [, options], callback) Launch remote hostname lookup - answer returnd as async ADDRMAP event Parameters: Name Type Argument Description address string Address to lookup options object &lt;optional&gt; Properties Name Type Argument Default Description reverse boolean &lt;optional&gt; false Perform reverse lookup callback TorController~resolveCallback Source: lib/controller.js saveConfig(callback) Tell Tor to write out it's config value to it's torrc Parameters: Name Type Description callback TorController~saveConfigCallback Source: lib/controller.js setCircuitPurpose(circuitId, purpose, callback) Sets the purpose of the given circuit Parameters: Name Type Description circuitId string The identifier for the circuit purpose string One of general|controller callback TorController~setCircuitPurposeCallback Source: lib/controller.js setConfig(keyword, value, callback) Change the value for a configuration variable Parameters: Name Type Description keyword string Configuration key value string New value to set callback TorController~setConfigCallback Source: lib/controller.js shutdown(callback) Controlled shutdown signal Parameters: Name Type Description callback TorController~shutdownCallback Source: lib/controller.js signal(signal, callback) Sends a signal to the control port Parameters: Name Type Description signal string callback TorController~signalCallback Source: lib/controller.js takeOwnership(callback) Take ownership of the tor process - will close tor when the connection closes Parameters: Name Type Description callback TorController~takeOwnershipCallback Source: lib/controller.js Type Definitions addEventListenersCallback(error) Parameters: Name Type Description error object | null Source: lib/controller.js attachStreamCallback(error) Parameters: Name Type Description error object | null Source: lib/controller.js cleanCircuitsCallback(error) Parameters: Name Type Description error object | null Source: lib/controller.js clearDnsCacheCallback(error) Parameters: Name Type Description error object | null Source: lib/controller.js closeCircuitCallback(error) Parameters: Name Type Description error object | null Source: lib/controller.js closeStreamCallback(error) Parameters: Name Type Description error object | null Source: lib/controller.js createAddressMappingCallback(error) Parameters: Name Type Description error object | null Source: lib/controller.js createCircuitCallback(error, result) Parameters: Name Type Description error object | null result Array.&lt;string&gt; Source: lib/controller.js createHiddenServiceCallback(error, result) Parameters: Name Type Description error object | null result AddOnionResult Source: lib/controller.js destroyHiddenServiceCallback(error) Parameters: Name Type Description error object | null Source: lib/controller.js dropGuardsCallback(error) Parameters: Name Type Description error object | null Source: lib/controller.js dumpHeartbeatCallback(error) Parameters: Name Type Description error object | null Source: lib/controller.js dumpStatsCallback(error) Parameters: Name Type Description error object | null Source: lib/controller.js enableDebugCallback(error) Parameters: Name Type Description error object | null Source: lib/controller.js extendCircuitCallback(error, result) Parameters: Name Type Description error object | null result Array.&lt;string&gt; Source: lib/controller.js fetchHiddenServiceDescriptorCallback(error) Parameters: Name Type Description error object | null Source: lib/controller.js getAuthChallengeCallback(error, result) Parameters: Name Type Description error object | null result AuthChallengeResult Source: lib/controller.js getConfigCallback(error, result) Parameters: Name Type Description error object | null result GetConfigResult Source: lib/controller.js getInfoCallback(error, result) Parameters: Name Type Description error object | null result string Source: lib/controller.js getProtocolInfoCallback(error, result) Parameters: Name Type Description error object | null result ProtocolInfoResult Source: lib/controller.js haltCallback(error) Parameters: Name Type Description error object | null Source: lib/controller.js loadConfigCallback(error) Parameters: Name Type Description error object | null Source: lib/controller.js postDescriptorCallback(error) Parameters: Name Type Description error object | null Source: lib/controller.js postHiddenServiceDescriptorCallback(error) Parameters: Name Type Description error object | null Source: lib/controller.js quitCallback(error) Parameters: Name Type Description error object | null Source: lib/controller.js redirectStreamCallback(error) Parameters: Name Type Description error object | null Source: lib/controller.js reloadConfigCallback(error) Parameters: Name Type Description error object | null Source: lib/controller.js removeEventListenersCallback(error) Parameters: Name Type Description error object | null Source: lib/controller.js resetConfigCallback(error) Parameters: Name Type Description error object | null Source: lib/controller.js resolveCallback(error) Parameters: Name Type Description error object | null Source: lib/controller.js saveConfigCallback(error) Parameters: Name Type Description error object | null Source: lib/controller.js setCircuitPurposeCallback(error) Parameters: Name Type Description error object | null Source: lib/controller.js setConfigCallback(error) Parameters: Name Type Description error object | null Source: lib/controller.js shutdownCallback(error) Parameters: Name Type Description error object | null Source: lib/controller.js signalCallback(error) Parameters: Name Type Description error object | null Source: lib/controller.js takeOwnershipCallback(error) Parameters: Name Type Description error object | null Source: lib/controller.js Events close Fires when the underlying socket closes Source: lib/controller.js error Fired when the underlying socket encounters an error Type: error Source: lib/controller.js ready Fires when the controller is authenticated and ready to send commands Source: lib/controller.js × Search results Close "},"tutorial-running-as-tor-user.html":{"id":"tutorial-running-as-tor-user.html","title":"Tutorial: Running as Tor User","body":" Granax Modules granaxgranax/commandsgranax/replies Classes TorController Events TorController#event:closeTorController#event:errorTorController#event:ready Tutorials Running as Tor User Running as Tor User GNU+LinuxMac OSXWindows × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
